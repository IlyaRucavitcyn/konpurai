ENTRA ID SSO BACKEND IMPLEMENTATION GUIDE
=========================================
Product Requirements & Technical Specifications for Development Team

OVERVIEW
========
This document provides detailed backend implementation requirements for integrating Microsoft Entra ID (Azure AD) SSO with VerifyWise. The frontend UI components are complete and ready for backend integration.

Frontend Integration Points:
- Settings > Entra ID > SSO Configuration tab
- Settings > Entra ID > Security Controls tab
- All form fields, validation, and user interactions are implemented
- Backend needs to provide API endpoints for CRUD operations and authentication flow


1. DATABASE SCHEMA DESIGN
=========================

1.1 SSO Configuration Table
---------------------------
Table: sso_configurations
- tenant_id (VARCHAR, Primary Key) - VerifyWise tenant identifier
- azure_tenant_id (VARCHAR, NOT NULL) - Azure AD Tenant ID (UUID format)
- azure_client_id (VARCHAR, NOT NULL) - Azure AD Application Client ID (UUID format)
- azure_client_secret (TEXT, ENCRYPTED, NOT NULL) - Azure AD Client Secret (encrypted at rest)
- cloud_environment (ENUM: 'AzurePublic', 'AzureGovernment', DEFAULT 'AzurePublic')
- email_claim (VARCHAR, DEFAULT 'email') - JWT claim for user email
- name_claim (VARCHAR, DEFAULT 'name') - JWT claim for user display name
- admin_groups (TEXT) - Comma-separated Azure AD group names for admin access
- auto_create_users (BOOLEAN, DEFAULT false) - Whether to auto-create users on first login
- default_role (VARCHAR, DEFAULT 'Reviewer') - Default role for new SSO users
- oauth_scopes (TEXT, DEFAULT 'openid profile email groups') - Space-separated OAuth scopes
- custom_claims (JSON) - Custom claim mappings from Azure AD to VerifyWise
- post_logout_redirect_uri (VARCHAR) - Redirect URL after logout
- is_enabled (BOOLEAN, DEFAULT false) - Whether SSO is active for this tenant
- created_at (TIMESTAMP)
- updated_at (TIMESTAMP)

1.2 Security Controls Table
---------------------------
Table: sso_security_controls
- tenant_id (VARCHAR, Primary Key, Foreign Key to sso_configurations)
- token_lifetime (ENUM: '1 Hour', '8 Hours', '24 Hours', DEFAULT '8 Hours')
- force_reauth_on_role_change (BOOLEAN, DEFAULT true)
- single_session_per_user (BOOLEAN, DEFAULT false)
- enable_sso_audit_logging (BOOLEAN, DEFAULT true)
- created_at (TIMESTAMP)
- updated_at (TIMESTAMP)

1.3 SSO Session Tracking
------------------------
Table: sso_sessions
- session_id (VARCHAR, Primary Key) - Unique session identifier
- user_id (INTEGER, Foreign Key to users table)
- tenant_id (VARCHAR, Foreign Key to sso_configurations)
- azure_ad_object_id (VARCHAR) - Azure AD user object ID
- token_expires_at (TIMESTAMP) - When the access token expires
- refresh_token_hash (VARCHAR, ENCRYPTED) - Hashed refresh token
- device_fingerprint (VARCHAR) - For single session enforcement
- ip_address (VARCHAR) - Client IP address
- user_agent (TEXT) - Client user agent
- last_activity (TIMESTAMP)
- created_at (TIMESTAMP)

1.4 SSO Audit Log
-----------------
Table: sso_audit_logs
- id (INTEGER, Primary Key, Auto Increment)
- tenant_id (VARCHAR, Foreign Key to sso_configurations)
- user_id (INTEGER, Foreign Key to users table, NULLABLE)
- event_type (ENUM: 'login_attempt', 'login_success', 'login_failure', 'logout', 'token_refresh', 'config_change')
- azure_ad_object_id (VARCHAR, NULLABLE)
- ip_address (VARCHAR)
- user_agent (TEXT)
- details (JSON) - Additional event-specific data
- timestamp (TIMESTAMP)


2. API ENDPOINTS SPECIFICATION
==============================

2.1 Configuration Management APIs
---------------------------------

GET /api/tenants/{tenantId}/sso/configuration
Purpose: Retrieve current SSO configuration
Response: {
  "azure_tenant_id": "uuid",
  "azure_client_id": "uuid",
  "cloud_environment": "AzurePublic",
  "email_claim": "email",
  "name_claim": "name",
  "admin_groups": "group1,group2",
  "auto_create_users": false,
  "default_role": "Reviewer",
  "oauth_scopes": "openid profile email groups",
  "custom_claims": {},
  "post_logout_redirect_uri": "https://...",
  "is_enabled": false
}

POST /api/tenants/{tenantId}/sso/configuration
Purpose: Create or update SSO configuration
Request Body: Same as GET response + azure_client_secret
Validation:
- azure_tenant_id and azure_client_id must be valid UUIDs
- azure_client_secret minimum 10 characters
- cloud_environment must be valid enum value
- Encrypt client_secret before storing

PUT /api/tenants/{tenantId}/sso/configuration/test-connection
Purpose: Test Azure AD connection with provided credentials
Request Body: {
  "azure_tenant_id": "uuid",
  "azure_client_id": "uuid",
  "azure_client_secret": "secret"
}
Process:
1. Make OAuth token request to Azure AD
2. Validate response and token structure
3. Test user info retrieval
Response: {
  "success": boolean,
  "message": "Connection successful!" | "Error details",
  "details": {} // Optional error details
}

GET /api/tenants/{tenantId}/sso/security-controls
POST /api/tenants/{tenantId}/sso/security-controls
Purpose: CRUD operations for security controls
Request/Response: {
  "token_lifetime": "8 Hours",
  "force_reauth_on_role_change": true,
  "single_session_per_user": false,
  "enable_sso_audit_logging": true
}

2.2 Authentication Flow APIs
---------------------------

GET /api/auth/sso/login/{tenantId}
Purpose: Initiate SSO login flow
Process:
1. Retrieve tenant SSO configuration
2. Generate state parameter for CSRF protection
3. Build Azure AD authorization URL
4. Store state in session/cache
Response: Redirect to Azure AD authorization endpoint

POST /api/auth/sso/callback
Purpose: Handle Azure AD callback
Process:
1. Validate state parameter against stored value
2. Exchange authorization code for tokens
3. Validate JWT tokens and extract claims
4. Find or create user based on email claim
5. Check group membership for admin rights
6. Create SSO session record
7. Generate VerifyWise session token
8. Audit log the login event

GET /api/auth/sso/logout
Purpose: Handle SSO logout
Process:
1. Terminate VerifyWise session
2. Clear SSO session record
3. Redirect to Azure AD logout endpoint
4. Audit log the logout event

POST /api/auth/sso/refresh-token
Purpose: Refresh expired access tokens
Process:
1. Validate current session
2. Use refresh token to get new access token
3. Update session expiry
4. Return new session information


3. AZURE AD INTEGRATION IMPLEMENTATION
======================================

3.1 OAuth 2.0 / OpenID Connect Flow
-----------------------------------

Authorization Endpoint:
https://login.microsoftonline.com/{tenant-id}/oauth2/v2.0/authorize

Required Parameters:
- client_id: Azure AD Application Client ID
- response_type: "code"
- redirect_uri: "{VERIFYWISE_BASE_URL}/api/auth/sso/callback"
- scope: Configured OAuth scopes (e.g., "openid profile email groups User.Read")
- state: CSRF protection token
- response_mode: "query"

Token Endpoint:
https://login.microsoftonline.com/{tenant-id}/oauth2/v2.0/token

Token Exchange Parameters:
- grant_type: "authorization_code"
- client_id: Azure AD Application Client ID
- client_secret: Azure AD Application Client Secret
- code: Authorization code from callback
- redirect_uri: Same as authorization request

3.2 JWT Token Validation
------------------------

Token Validation Steps:
1. Verify JWT signature using Azure AD public keys
2. Validate token expiration (exp claim)
3. Validate audience (aud claim) matches client_id
4. Validate issuer (iss claim) matches expected Azure AD endpoint
5. Extract user claims (email, name, groups, etc.)

Required Libraries:
- JWT validation library (jsonwebtoken, jose, etc.)
- HTTP client for Azure AD API calls
- Cryptographic library for token signature verification

3.3 User Information Retrieval
------------------------------

Microsoft Graph API Endpoints:
- User Profile: GET https://graph.microsoft.com/v1.0/me
- User Groups: GET https://graph.microsoft.com/v1.0/me/memberOf

Headers:
- Authorization: Bearer {access_token}
- Content-Type: application/json

Group Membership Validation:
1. Retrieve user's group memberships from Graph API
2. Compare against configured admin_groups
3. Assign appropriate role based on membership


4. USER MANAGEMENT INTEGRATION
==============================

4.1 User Creation/Update Logic
------------------------------

Auto-Create Users Flow:
IF auto_create_users == true:
  1. Check if user exists by email claim
  2. If not exists:
     - Create new user record
     - Set default_role from configuration
     - Mark as SSO user (add sso_enabled flag)
     - Set initial permissions based on role
  3. If exists:
     - Update user information from claims
     - Update last_login timestamp

Manual User Management:
IF auto_create_users == false:
  1. Check if user exists and has SSO enabled
  2. If user doesn't exist, reject login with error
  3. If user exists but SSO disabled, reject login
  4. If user exists and SSO enabled, proceed with login

4.2 Role and Permission Mapping
-------------------------------

Admin Rights Assignment:
1. Extract groups claim from JWT token
2. Check if any user groups match admin_groups configuration
3. If match found, assign admin role and permissions
4. If no match, assign default_role from configuration

Role Update Process:
IF force_reauth_on_role_change == true:
  1. Compare current user role with previous login
  2. If role changed, invalidate all existing sessions
  3. Force user to re-authenticate
  4. Update role and permissions after re-auth

4.3 Custom Claims Processing
----------------------------

Custom Claims Mapping:
1. Parse custom_claims JSON configuration
2. Extract specified claims from JWT token
3. Map Azure AD claims to VerifyWise user attributes
4. Update user profile with mapped attributes

Example Configuration:
{
  "department": "extension_Department",
  "employee_id": "extension_EmployeeId",
  "job_title": "jobTitle",
  "manager": "manager"
}


5. SESSION MANAGEMENT IMPLEMENTATION
====================================

5.1 Session Creation and Validation
-----------------------------------

Session Creation:
1. Generate unique session_id (UUID)
2. Calculate token_expires_at based on token_lifetime setting
3. Hash and store refresh_token securely
4. Record device_fingerprint for session tracking
5. Store session in sso_sessions table

Session Validation Middleware:
1. Extract session token from request headers
2. Validate session exists and not expired
3. Check device_fingerprint if single_session_per_user enabled
4. Update last_activity timestamp
5. Return user context for request processing

5.2 Single Session Enforcement
------------------------------

IF single_session_per_user == true:
  1. Before creating new session, invalidate all existing sessions for user
  2. Check device_fingerprint on each request
  3. If device_fingerprint mismatch, terminate session
  4. Maintain only one active session per user at any time

Device Fingerprinting:
- Combine IP address + User-Agent hash
- Store fingerprint with session
- Validate on each authenticated request

5.3 Token Refresh Mechanism
---------------------------

Automatic Token Refresh:
1. Monitor access token expiration
2. Use refresh_token to obtain new access_token
3. Update session expiry time
4. Handle refresh token expiration (force re-login)

Refresh Token Security:
- Hash refresh tokens before storage
- Rotate refresh tokens on each use
- Set appropriate expiration times
- Revoke on logout or session termination


6. SECURITY CONTROLS IMPLEMENTATION
===================================

6.1 Token Lifetime Management
-----------------------------

Token Expiration Handling:
- 1 Hour: High security environments, frequent re-validation
- 8 Hours: Standard business day, balanced security/UX
- 24 Hours: Extended access, lower security requirements

Implementation:
1. Set session expiry based on token_lifetime configuration
2. Implement sliding window expiration (extend on activity)
3. Force re-authentication when token expires
4. Provide warning notifications before expiration

6.2 Re-authentication Triggers
------------------------------

Force Re-authentication Scenarios:
1. Role/permission changes (if enabled)
2. Security control configuration changes
3. Password reset in Azure AD
4. Suspicious activity detection
5. Manual session termination by admin

Implementation:
1. Monitor for trigger conditions
2. Invalidate affected sessions
3. Redirect users to SSO login flow
4. Log re-authentication events

6.3 Audit Logging Implementation
--------------------------------

Audit Event Types:
- login_attempt: User initiated SSO login
- login_success: Successful authentication
- login_failure: Failed authentication with reason
- logout: User-initiated or automatic logout
- token_refresh: Token refresh operations
- config_change: SSO configuration modifications
- session_terminated: Forced session termination

Audit Data Collection:
1. Capture all authentication events
2. Log IP addresses and user agents
3. Record timestamps with timezone
4. Store event details in structured JSON
5. Ensure tamper-proof logging mechanism

Audit Log Analysis:
- Failed login attempt monitoring
- Unusual activity pattern detection
- Compliance reporting capabilities
- Security incident investigation support


7. ERROR HANDLING AND EDGE CASES
=================================

7.1 Azure AD Integration Errors
-------------------------------

Connection Failures:
- Network timeouts to Azure AD endpoints
- Invalid credentials (tenant_id, client_id, client_secret)
- Azure AD service unavailability
- Invalid or expired authorization codes

Error Response Format:
{
  "error": "authentication_failed",
  "message": "User-friendly error description",
  "details": {
    "error_code": "AZURE_AD_ERROR_CODE",
    "timestamp": "2024-01-01T00:00:00Z",
    "correlation_id": "unique-id-for-tracking"
  }
}

7.2 User Management Errors
--------------------------

User Creation Failures:
- Duplicate email addresses
- Invalid user data from claims
- Missing required claims
- Database constraint violations

Group Membership Issues:
- User not member of any admin groups
- Group names changed in Azure AD
- Group access permissions revoked
- Nested group membership handling

7.3 Session Management Errors
-----------------------------

Session Conflicts:
- Multiple concurrent login attempts
- Session hijacking attempts
- Device fingerprint mismatches
- Token replay attacks

Cleanup Operations:
- Expired session removal
- Orphaned session handling
- Failed logout cleanup
- Database connection failures


8. SECURITY BEST PRACTICES
===========================

8.1 Data Protection
-------------------

Encryption Requirements:
- Encrypt client_secret at rest using AES-256
- Hash refresh tokens using bcrypt or Argon2
- Use TLS 1.3 for all external communications
- Implement proper key rotation procedures

Sensitive Data Handling:
- Never log client_secret or tokens
- Mask sensitive data in error messages
- Implement secure token storage
- Regular security audits and penetration testing

8.2 CSRF Protection
-------------------

State Parameter Implementation:
1. Generate cryptographically secure random state
2. Store state in server-side session/cache
3. Include state in Azure AD authorization URL
4. Validate state parameter in callback
5. Implement state expiration (5-10 minutes)

8.3 Rate Limiting
-----------------

Login Attempt Limiting:
- Implement rate limiting per IP address
- Account lockout after failed attempts
- Progressive delay on repeated failures
- Captcha integration for suspicious activity

API Rate Limiting:
- Limit configuration API calls per tenant
- Throttle token refresh requests
- Monitor for abuse patterns
- Implement circuit breaker patterns


9. MONITORING AND OBSERVABILITY
===============================

9.1 Metrics Collection
----------------------

Key Performance Indicators:
- SSO login success/failure rates
- Authentication response times
- Token refresh frequency
- Session duration statistics
- API endpoint performance

Health Check Endpoints:
- /api/health/sso - SSO service health
- /api/health/azure-ad - Azure AD connectivity
- /api/health/database - Database connectivity

9.2 Logging Strategy
-------------------

Structured Logging Format:
{
  "timestamp": "2024-01-01T00:00:00Z",
  "level": "INFO|WARN|ERROR",
  "service": "sso-service",
  "tenant_id": "tenant-uuid",
  "user_id": "user-id",
  "event": "login_success",
  "duration_ms": 150,
  "ip_address": "192.168.1.1",
  "user_agent": "browser-info"
}

Log Retention:
- Security logs: 2 years minimum
- Performance logs: 90 days
- Debug logs: 30 days
- Compliance logs: Per regulatory requirements

9.3 Alerting Configuration
--------------------------

Critical Alerts:
- SSO service unavailability
- High authentication failure rates
- Azure AD connectivity issues
- Security policy violations
- Database connection failures

Warning Alerts:
- Unusual login patterns
- Token refresh failures
- Configuration changes
- Performance degradation


10. DEPLOYMENT AND CONFIGURATION
=================================

10.1 Environment Variables
--------------------------

Required Configuration:
- AZURE_AD_AUTHORITY_URL: https://login.microsoftonline.com
- VERIFYWISE_BASE_URL: Application base URL for redirects
- DATABASE_URL: Database connection string
- ENCRYPTION_KEY: For encrypting sensitive data
- JWT_SECRET: For signing session tokens
- LOG_LEVEL: Logging verbosity
- REDIS_URL: For session caching (optional)

10.2 Database Migrations
------------------------

Migration Scripts:
1. Create sso_configurations table
2. Create sso_security_controls table
3. Create sso_sessions table
4. Create sso_audit_logs table
5. Add indexes for performance
6. Set up foreign key constraints

Performance Indexes:
- sso_sessions(user_id, expires_at)
- sso_audit_logs(tenant_id, timestamp)
- sso_configurations(tenant_id)

10.3 Testing Strategy
--------------------

Unit Tests:
- JWT token validation logic
- User creation/update flows
- Session management functions
- Configuration validation
- Error handling scenarios

Integration Tests:
- Azure AD OAuth flow end-to-end
- Database operations
- API endpoint functionality
- Security control enforcement

Load Testing:
- Concurrent login scenarios
- Token refresh under load
- Database performance
- Azure AD rate limiting


IMPLEMENTATION TIMELINE
=======================

Phase 1 (Week 1-2): Core Infrastructure
- Database schema implementation
- Basic API endpoints
- Configuration management

Phase 2 (Week 3-4): Authentication Flow
- Azure AD OAuth integration
- JWT token validation
- User management integration

Phase 3 (Week 5-6): Security & Session Management
- Session management implementation
- Security controls enforcement
- Audit logging system

Phase 4 (Week 7-8): Testing & Deployment
- Comprehensive testing
- Security review
- Production deployment
- Documentation completion

FRONTEND INTEGRATION NOTES
==========================

The frontend UI components are ready and expect these API endpoints:
- GET/POST /api/tenants/{tenantId}/sso/configuration
- GET/POST /api/tenants/{tenantId}/sso/security-controls
- POST /api/tenants/{tenantId}/sso/configuration/test-connection

Form validation is handled client-side, but server-side validation must be implemented for all endpoints. The UI provides real-time feedback based on API responses.

ERROR RESPONSE FORMAT
=====================

All API endpoints should return consistent error responses:
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "User-friendly error message",
    "details": {},
    "timestamp": "2024-01-01T00:00:00Z"
  }
}

Success responses:
{
  "success": true,
  "data": { /* response data */ },
  "timestamp": "2024-01-01T00:00:00Z"
}

This implementation guide provides the development team with comprehensive requirements to build a production-ready Entra ID SSO integration that connects seamlessly with the existing frontend UI components.